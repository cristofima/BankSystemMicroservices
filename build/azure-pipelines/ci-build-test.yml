trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
  paths:
    include:
      - 'src/gateway/**'
      - 'src/services/**/src/**'
      - 'src/services/**/tests/**'
      - 'src/shared/**'
      - 'build/azure-pipelines/ci-build-test.yml'
    exclude:
      - 'src/gateway/**/*.md'
      - 'src/services/**/*.md'
      - 'src/services/**/README.md'
      - 'src/shared/*.md'

variables:
  buildConfiguration: 'Release'
  solution: 'src/BankSystem.sln'
  testProjectsPattern: 'src/**/tests/**/*.csproj'
  resultsDirectory: '$(Agent.TempDirectory)/TestResults'

stages:
- stage: BuildAndTest
  jobs:

  - job: Ubuntu
    displayName: 'Ubuntu Agent'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET 9 SDK'
      inputs:
        packageType: 'sdk'
        version: '9.x'

    # Check what type of changes were made to optimize pipeline execution
    - bash: |
        echo "Analyzing changes to optimize pipeline execution..."
        
        # Get list of changed files
        if [ "$(Build.Reason)" = "PullRequest" ]; then
          # For PR builds, compare with target branch
          TARGET_REF="$(System.PullRequest.TargetBranch)"
          # Azure provides refs/heads/xxx â€“ trim prefix for remote ref
          TARGET_BRANCH=${TARGET_REF#refs/heads/}
          git fetch origin "$TARGET_BRANCH"
          CHANGED_FILES=$(git diff --name-only HEAD "origin/$TARGET_BRANCH" || true)
        else
          # For CI builds, compare with previous commit
          CHANGED_FILES=$(git diff --name-only $(git rev-list --max-parents=0 HEAD)..HEAD || true)
        fi
        # Fail-safe defaults (in case any git command above fails)
        echo "##vso[task.setvariable variable=SkipSonarQube]true"
        echo "##vso[task.setvariable variable=SendCoverageToSonar]false"
        echo "##vso[task.setvariable variable=RunWithoutCoverage]false"
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check if any non-documentation files were changed
        CODE_CHANGES=$(echo "$CHANGED_FILES" | grep -v '\.md$' | grep -v 'README' | grep -v 'docs/' | wc -l)
        
        # Check if any files that affect coverage were changed (source code in src/, not config/build files)
        COVERAGE_AFFECTING_CHANGES=$(echo "$CHANGED_FILES" | grep -E '\.(cs|fs|vb)$' | grep -E '^src/(services|shared)/' | grep -v '/bin/' | grep -v '/obj/' | wc -l)
        
        echo "Number of code changes: $CODE_CHANGES"
        echo "Number of coverage-affecting changes: $COVERAGE_AFFECTING_CHANGES"
        
        # Strategy: Always collect coverage for unit tests, but only send to SonarQube when needed
        if [ "$CODE_CHANGES" -eq 0 ]; then
          echo "Only documentation files changed - skipping SonarQube analysis entirely"
          echo "##vso[task.setvariable variable=SkipSonarQube]true"
          echo "##vso[task.setvariable variable=SendCoverageToSonar]false"
          echo "##vso[task.setvariable variable=RunWithoutCoverage]false"
        else
          echo "Code files changed - running SonarQube analysis"
          echo "##vso[task.setvariable variable=SkipSonarQube]false"
          
          # Logic: If ANY file requires coverage, run ALL tasks WITH coverage
          if [ "$COVERAGE_AFFECTING_CHANGES" -gt 0 ]; then
            echo "Coverage-affecting changes detected - running SonarQube WITH coverage data"
            echo "##vso[task.setvariable variable=SendCoverageToSonar]true"
            echo "##vso[task.setvariable variable=RunWithoutCoverage]false"
          else
            echo "No coverage-affecting changes - running SonarQube WITHOUT coverage data"
            echo "##vso[task.setvariable variable=SendCoverageToSonar]false"
            echo "##vso[task.setvariable variable=RunWithoutCoverage]true"
          fi
        fi
      displayName: "Analyze Changes for Pipeline Optimization"

    # Docker is already installed & running on ubuntu-latest
    - bash: docker info
      displayName: "Verify Docker engine"

    # Clear SonarQube cache to prevent hanging issues
    - bash: |
        rm -rf ~/.sonar/cache || true
        echo "SonarQube cache cleared"
      displayName: "Clear SonarQube Cache"
      condition: and(succeeded(), ne(variables['SONAR_PROJECT_KEY'], ''))

    - task: SonarQubePrepare@7
      displayName: 'Prepare SonarQube Analysis (WITH Coverage Data)'
      inputs:
        SonarQube: 'SonarQube'
        organization: '$(SONAR_ORGANIZATION)'
        scannerMode: 'dotnet'
        projectKey: '$(SONAR_PROJECT_KEY)'
        projectName: '$(SONAR_PROJECT_NAME)'
        extraProperties: |
          sonar.exclusions=**/bin/**,**/obj/**,**/Migrations/**,**/*.Designer.cs,**/*ModelSnapshot.cs
          sonar.test.exclusions=**/bin/**,**/obj/**
          sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/*.xml
          sonar.cs.vstest.reportsPaths=$(Agent.TempDirectory)/**/*.trx
          sonar.sourceEncoding=UTF-8
          sonar.coverage.exclusions=**/*.md,**/README.*,**/docs/**/*.md,**/docs/**/*.y?(a)ml
      condition: and(succeeded(), ne(variables['SONAR_PROJECT_KEY'], ''), ne(variables['SkipSonarQube'], 'true'), eq(variables['SendCoverageToSonar'], 'true'))
      timeoutInMinutes: 10

    - task: SonarQubePrepare@7
      displayName: 'Prepare SonarQube Analysis (WITHOUT Coverage Data)'
      inputs:
        SonarQube: 'SonarQube'
        organization: '$(SONAR_ORGANIZATION)'
        scannerMode: 'dotnet'
        projectKey: '$(SONAR_PROJECT_KEY)'
        projectName: '$(SONAR_PROJECT_NAME)'
        extraProperties: |
          sonar.exclusions=**/bin/**,**/obj/**,**/Migrations/**,**/*.Designer.cs,**/*ModelSnapshot.cs
          sonar.test.exclusions=**/bin/**,**/obj/**
          sonar.sourceEncoding=UTF-8
      condition: and(succeeded(), ne(variables['SONAR_PROJECT_KEY'], ''), ne(variables['SkipSonarQube'], 'true'), eq(variables['RunWithoutCoverage'], 'true'))
      timeoutInMinutes: 10

    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet packages'
      inputs:
        command: 'restore'
        projects: '$(solution)'

    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: 'build'
        projects: '$(solution)'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: 'Run All Unit Tests with Code Coverage'
      inputs:
        command: 'test'
        projects: |
          src/services/**/tests/**/*UnitTests.csproj
          src/shared/tests/**/*UnitTests.csproj
        arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage" --settings "$(Build.SourcesDirectory)/src/coverlet.runsettings"'
        publishTestResults: true

    - task: DotNetCoreCLI@2
      displayName: 'Run All Integration Tests with Code Coverage'
      inputs:
        command: 'test'
        projects: 'src/services/**/tests/**/*IntegrationTests.csproj'
        arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage" --settings "$(Build.SourcesDirectory)/src/coverlet.runsettings"'
        publishTestResults: true
      # Note: TestContainers will automatically use Docker on Linux
      continueOnError: true

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage to Azure DevOps'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
        pathToSources: '$(Build.SourcesDirectory)/src'
        failIfCoverageEmpty: false
      condition: and(succeeded(), ne(variables['SkipCoverage'], 'true'))

    # Optional: Add delay before SonarQube analysis to help with rate limiting
    - bash: |
        echo "Waiting before SonarQube analysis to prevent rate limiting..."
        sleep 15
      displayName: "Pre-Analysis Delay"
      condition: and(succeeded(), ne(variables['SONAR_PROJECT_KEY'], ''), ne(variables['SkipSonarQube'], 'true'))

    - task: SonarQubeAnalyze@7
      displayName: 'Run SonarQube Analysis'
      condition: and(succeeded(), ne(variables['SONAR_PROJECT_KEY'], ''), ne(variables['SkipSonarQube'], 'true'))
      timeoutInMinutes: 15

    - task: SonarQubePublish@7
      displayName: 'Publish SonarQube Quality Gate Result'
      inputs:
        pollingTimeoutSec: '300'
      condition: and(succeeded(), ne(variables['SONAR_PROJECT_KEY'], ''), ne(variables['SkipSonarQube'], 'true'))